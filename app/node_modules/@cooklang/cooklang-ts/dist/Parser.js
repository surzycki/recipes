"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tokens_1 = require("./tokens");
class Parser {
    constructor(options) {
        this.defaultUnits = '';
        this.defaultCookwareAmount = options?.defaultCookwareAmount ?? 1;
        this.defaultIngredientAmount = options?.defaultIngredientAmount ?? 'some';
        this.includeStepNumber = options?.includeStepNumber ?? false;
    }
    parse(source) {
        const ingredients = [];
        const cookwares = [];
        const metadata = {};
        const steps = [];
        const shoppingList = {};
        source = source.replace(tokens_1.comment, '').replace(tokens_1.blockComment, ' ');
        for (let match of source.matchAll(tokens_1.shoppingList)) {
            const groups = match.groups;
            if (!groups)
                continue;
            shoppingList[groups.name] = parseShoppingListCategory(groups.items || '');
            source = source.substring(0, match.index || 0);
            +source.substring((match.index || 0) + match[0].length);
        }
        const lines = source.split(/\r?\n/).filter((l) => l.trim().length > 0);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const step = [];
            let pos = 0;
            for (let match of line.matchAll(tokens_1.tokens)) {
                const groups = match.groups;
                if (!groups)
                    continue;
                if (pos < (match.index || 0)) {
                    step.push({
                        type: 'text',
                        value: line.substring(pos, match.index),
                    });
                }
                if (groups.key && groups.value) {
                    metadata[groups.key.trim()] = groups.value.trim();
                }
                if (groups.sIngredientName) {
                    const ingredient = {
                        type: 'ingredient',
                        name: groups.sIngredientName,
                        quantity: this.defaultIngredientAmount,
                        units: this.defaultUnits,
                    };
                    if (this.includeStepNumber)
                        ingredient.step = i;
                    ingredients.push(ingredient);
                    step.push(ingredient);
                }
                if (groups.mIngredientName) {
                    const ingredient = {
                        type: 'ingredient',
                        name: groups.mIngredientName,
                        quantity: parseQuantity(groups.mIngredientQuantity) ??
                            this.defaultIngredientAmount,
                        units: parseUnits(groups.mIngredientUnits) ?? this.defaultUnits,
                    };
                    if (this.includeStepNumber)
                        ingredient.step = i;
                    ingredients.push(ingredient);
                    step.push(ingredient);
                }
                if (groups.sCookwareName) {
                    const cookware = {
                        type: 'cookware',
                        name: groups.sCookwareName,
                        quantity: this.defaultCookwareAmount,
                    };
                    if (this.includeStepNumber)
                        cookware.step = i;
                    cookwares.push(cookware);
                    step.push(cookware);
                }
                if (groups.mCookwareName) {
                    const cookware = {
                        type: 'cookware',
                        name: groups.mCookwareName,
                        quantity: parseQuantity(groups.mCookwareQuantity) ??
                            this.defaultCookwareAmount,
                    };
                    if (this.includeStepNumber)
                        cookware.step = i;
                    cookwares.push(cookware);
                    step.push(cookware);
                }
                if (groups.timerQuantity) {
                    step.push({
                        type: 'timer',
                        name: groups.timerName,
                        quantity: parseQuantity(groups.timerQuantity) ?? 0,
                        units: parseUnits(groups.timerUnits) ?? this.defaultUnits,
                    });
                }
                pos = (match.index || 0) + match[0].length;
            }
            if (pos < line.length) {
                step.push({
                    type: 'text',
                    value: line.substring(pos),
                });
            }
            if (step.length > 0)
                steps.push(step);
        }
        return { ingredients, cookwares, metadata, steps, shoppingList };
    }
}
exports.default = Parser;
function parseQuantity(quantity) {
    if (!quantity || quantity.trim() === '') {
        return undefined;
    }
    quantity = quantity.trim();
    const [left, right] = quantity.split('/');
    const [numLeft, numRight] = [Number(left), Number(right)];
    if (right && isNaN(numRight))
        return quantity;
    if (!isNaN(numLeft) && !numRight)
        return numLeft;
    else if (!isNaN(numLeft) && !isNaN(numRight) && !(left.startsWith('0') || right.startsWith('0')))
        return numLeft / numRight;
    return quantity.trim();
}
function parseUnits(units) {
    if (!units || units.trim() === "") {
        return undefined;
    }
    return units.trim();
}
function parseShoppingListCategory(items) {
    const list = [];
    for (let item of items.split('\n')) {
        item = item.trim();
        if (item == '')
            continue;
        const [name, synonym] = item.split('|');
        list.push({
            name: name.trim(),
            synonym: synonym?.trim() || '',
        });
    }
    return list;
}
//# sourceMappingURL=Parser.js.map